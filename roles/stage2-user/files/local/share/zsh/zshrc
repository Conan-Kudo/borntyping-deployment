#!/bin/zsh
#
# A minimal .zshrc
#
# Author: Sam Clements <sam@borntyping.co.uk>
# Licence: MIT
#

setopt INTERACTIVE_COMMENTS             # Allow comments in interactive mode
setopt RM_STAR_WAIT                     # Force the user to wait before `rm *`

#
# History settings
#

SAVEHIST=10000                          # Lines of history to save to a file
HISTSIZE=10000                          # Lines of history to keep in memory
HISTFILE=$HOME/.zhistory                # Save history in .cache

setopt APPEND_HISTORY                   # Append to $HISTFILE, not replace
setopt INC_APPEND_HISTORY               # Append to $HISTFILE while running
setopt SHARE_HISTORY                    # Share history between ZSH instances
setopt EXTENDED_HISTORY                 # Record additional information

setopt HIST_IGNORE_DUPS                 # Ignore adjacent reapeated entries
setopt HIST_EXPIRE_DUPS_FIRST           # Remove duplicate entries first
setopt HIST_FIND_NO_DUPS                # Never find duplicates when searching

#
# Completion
#

fpath=("$HOME/.local/share/zsh/functions" $fpath)

autoload -Uz compinit && compinit       # Loads completion modules
setopt AUTO_MENU                        # Show completion menu on succesive tab press
setopt ALWAYS_TO_END                    # Move cursor after completion
setopt COMPLETE_ALIASES                 # Allow autocompletion for aliases
setopt COMPLETE_IN_WORD                 # Allow completion from middle of word
setopt LIST_PACKED                      # Smallest completion menu
setopt AUTO_PARAM_KEYS                  # Intelligent handling of characters
setopt AUTO_PARAM_SLASH                 #   after a completion
setopt AUTO_REMOVE_SLASH

zstyle ':completion:*' list-colors ''
zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion::complete:*' use-cache on
zstyle ':completion::complete:*' cache-path "$HOME/.cache/zsh/completion/"
zstyle ':completion:*:*:*:users' ignored-patterns '*'
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}' 'r:|[._-]=* r:|=*' 'l:|=* r:|=*'

#
# Prompt
#

autoload -U vcs_info                    # Version control information
autoload -U colors && colors            # Adds variables for printing colors
setopt PROMPT_SUBST                     # Allow substitution in PROMPT

zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:*' check-for-staged-changes true
zstyle ':vcs_info:*' stagedstr "%{$fg[green]%}!%{$reset_color%}"
zstyle ':vcs_info:*' unstagedstr "%{$fg[yellow]%}!%{$reset_color%}"
zstyle ':vcs_info:*' formats "%{$fg_bold[green]%}%s:%{$fg_bold[green]%}%b%{$reset_color%}%c%u%m "
zstyle ':vcs_info:*' actionformats "%{$fg_bold[green]%}%s:%{$fg_bold[green]%}%b%{$reset_color%}(%a)%c%u%m "
zstyle ':vcs_info:git*+set-message:*' hooks git-untracked git-remote

# Add a marker to %u for untracked files
function +vi-git-untracked(){
    if git status --porcelain | fgrep '??' &> /dev/null; then
        hook_com[unstaged]+="%{$fg[red]%}!%{$reset_color%}"
    fi
}

# Show +N/-N when a local branch is ahead-of or behind remote HEAD.
function +vi-git-remote() {
    local ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)
    (( $ahead )) && hook_com[misc]+=" %{$fg_bold[green]%}+${ahead}%{$reset_color%}"

    local behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
    (( $behind )) && hook_com[misc]+=" %{$fg[red]%}-${behind}%{$reset_color%}"
}

# Load virtualenvwrapper, and stop virtualenv from modifying the prompt
if [[ -f /usr/share/virtualenvwrapper/virtualenvwrapper.sh ]]; then
    export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
    export VIRTUAL_ENV_DISABLE_PROMPT=1
    source /usr/share/virtualenvwrapper/virtualenvwrapper.sh
fi

# Display the current virtualenv when active
function _info_virtualenv() {
    if [ -n "$VIRTUAL_ENV" ]; then
        INFO_MSGS_VIRTUALENV="%{$fg_bold[green]%}virtualenv:$(basename "$VIRTUAL_ENV")%{$reset_color%} "
    else
        INFO_MSGS_VIRTUALENV=""
    fi
}

# Display the currently selected knife-block configuration file
#

# If the selected configuration is `none` the information will not be shown, and
# if the selected configuration is `production` it will be shown in red.
function _info_knife() {
    INFO_MSGS_KNIFE=""

    [[ ! -L "$HOME/.chef/knife.rb" ]] && return

    local ENVIRONMENT_FILE=$(realpath "$HOME/.chef/knife.rb")
    local ENVIRONMENT=$(basename $ENVIRONMENT_FILE | sed "s/knife-\(.*\).rb/\1/")
    local COLOUR="$fg_bold[green]"

    # When the environment is `none`, skip showing knife information
    [[ "$ENVIRONMENT" == "none" ]] && return

    # Set colors based on the environment
    [[ "$ENVIRONMENT" == "production"  ]] && COLOUR="$fg[red]"
    [[ "$ENVIRONMENT" == "staging"     ]] && COLOUR="$fg[yellow]"
    [[ "$ENVIRONMENT" == "development" ]] && COLOUR="$fg[green]"

    ENVIRONMENT="%{$COLOUR%}${ENVIRONMENT}%{$reset_color%}"
    INFO_MSGS_KNIFE="%{$fg_bold[green]%}knife:%{$reset_color%}${ENVIRONMENT} "
}

# Assemble the prompt
#   sam@hostname ~ $
#   sam@hostname ~/directory git:master env:virtualenv knife:production $
#
# The %{ and %} characters are used to stop the prompt from counting invisible
# characters when calculating the length
PROMPT="\
%{$fg_bold[green]%}$ %n@%m %~%{$reset_color%} \
\${vcs_info_msg_0_}\${INFO_MSGS_VIRTUALENV}\${INFO_MSGS_KNIFE}
%{$fg_bold[blue]%}$%{$reset_color%} "

#
# Title
#

# Set terminal title and collect information before showing the prompt
function precmd() {
    case $TERM in
        xterm*) print -Pn "\e]2;%~\a";;
    esac
    vcs_info
    _info_virtualenv
    _info_knife
}

# Set terminal title before executing a command
function preexec() {
    case $TERM in
        xterm*) print -Pn "\e]2;%~ $ $2\a";;
    esac
}

#
# Aliases
#

alias ls='ls --color=auto --hide="*.sublime-*"'
alias grep='grep --color=auto'          # Use colors for grep output
alias -g ...='../..'                    # Allow ... to mean ../.. anywhere

alias gd='git diff'
alias gs='git status'
alias gc='git commit -v'
alias gca='git commit -v -a'

function alert() {
    local success=$?
    local command=$history[$HISTCMD]
    local icons="/usr/share/icons/Mint-X/status/scalable"

    if [[ $success == 0 ]]; then
        notify-send -i "${icons}/dialog-warning-symbolic.svg" \
            "Command finished: ${command:0:-7}"
    else
        notify-send -i "${icons}/dialog-error-symbolic.svg" \
            "Command failed: ${command:0:-7}"
    fi
}

#
# Environment variables
#

export EDITOR=nano
export LS_COLORS='rs=0:di=01;34:ln=target:or=41:ex=32'

#
# Named directories
#

setopt AUTO_NAME_DIRS                   # Use named directories
borntyping="$HOME/Development/borntyping"
datasift="$HOME/Development/datasift"
sandbox="$HOME/Development/borntyping-sandbox"
src="$HOME/Development/src"

#
# Add directories to $PATH if they exist
#

function add_to_path() { [[ -d $1 ]] && export PATH="$1:$PATH" }

add_to_path "${datasift}/chef/bin"      # Chef scripts
add_to_path "$HOME/.gem/ruby/2.0.0/bin" # Executables installed by 'gem'
add_to_path "$HOME/.gem/ruby/2.1.0/bin" # Executables installed by 'gem'
add_to_path "$HOME/.local/bin"          # User installed executables
add_to_path "$HOME/.bin"                # Personal scripts

#
# Plugins
#

source "$HOME/.local/share/zsh/plugins/syntax-highlighting/zsh-syntax-highlighting.zsh"
